# PS快捷键
* 新建：ctrl+N
* 打开：ctrl+O
* 保存：ctrl+S
* 复制：ctrl+C
* 粘贴：ctrl+V
* 剪切：ctrl+X
* 全选：ctrl+A
* 回退：ctrl+Z
* 取消选区：ctrl+D
* 反选：ctrl+shift +i
* 羽化：shift+f6
* 变形：ctrl+T
* 吸管：I
* shift：1:1 比例
* 复制图层：ctrl+j
* 打组：ctrl+G
* 图层向上移动：ctrl+ ]
* 图层向下移动：ctrl+ [
* 移到该组最顶层：ctrl+shift+]
* ctrl+点击    实现每次多选一个图层
* shift+点击    实现连续多个图层
* ctrl+点击缩略图    能把该图层的选区画出来
* ctrl+1 缩放到100%比例
* ctrl+“+”放大
* ctrl+”-”缩小
* 调出标尺  CTRL+R
* 隐藏标尺和选区  ctrl+H
* alt+↑    缩小行间距
* alt+↓    增大行间距
* alt+→   增大文字与文字之间的间距
* alt+←  缩小文字与文字的间距

# HTML
## 相对路径
查找相对路径的方式：以自身文件出发去查找目标文件
细分分三类：
* A、平级查找 ---- 自身（html文件）和目标文件在同一个文件夹  
> 路径写法：直接书写文件名字  src=“*.jpg”
* B、下级查找 （同级文件夹里面查找）  
> 路径写法：文件夹名称/文件名字  src=“img/*.jpg”
* C、上级查找（所在文件夹外面查找） src=“../*.jpg”  
> 路径写法： ../文件名字 表示返回上一级，../../表示返回上两级

## 绝对路径
绝对路径：一般指的是带有盘符的路径（不推荐使用）
* A、盘符出发 D://或者file:///D     
> 例如：F:\1课件\1html\html01\1案例\7相对路径\3shangji
* B、互联网地址  http://                 
> 例如： https://www.baidu.com

## 锚点链接

步骤：
* 1.在跳转的目的地添加锚点,实现方式：给目的地标签加name属性，name属性值为“锚记名称”    
<标签 name=“锚记名称” id=“锚记名称”></标签>
* 2.在页面中添加超链接，href地址写法为“#锚记名称”，这个超链接也就叫做锚点链接  
<a href=“#锚记名称”>返回顶部</a>

## 表格
* tr表示的是行
* th 表示表头单元格
* td表示的是单元格
* cellpadding：内容和单元格边缘的距离
* cellspacing：单元格与单元格之间的距离
* border：表格的粗细，如果设置为0的话，就没有边框

## 单选按钮
input标签type取值为radio的时候，input就变成了单选按钮

    <input type="radio">男  
    <input type="radio">女 
     

#### a.实现单选按钮功能
同一个选项里面的单选按钮：	input标签里面加相同的name=”自定义name值”，就可以实现多个单选按钮每次只能选中一个

    <div>
    <input type="radio" name="sex">男 
    <input type="radio" name="sex">女
    </div>


#### b.扩大单选按钮触发区域
* 在文字上添加label标签，并且在标签身上添加一个for=“”属性
* 在想要触发的radio上添加id属性，id属性的值必须等于for属性的值

    <div>
    <input type="radio" name="sex" id="boy">
    	<label for="boy">男</label>
    <input type="radio" name="sex" id="girl">
    	<label for="girl">女</label>
    </div>


#### c.默认选中
需要在input标签加 checked=“checked”

    <input type="radio" name="sex" id="boy">
    <label for="boy">男</label>
    <input type="radio" name="sex" id="girl" checked="checked">
    <label for="girl">女</label>


## 表单域form
* action=“提交数据的地址”，前台工作人员不知道这个地址，留空即可
* method=“提交数据方式”
    * get明文发送，默认值
    * post密文发送
注意：想要将表单数据提交给服务器，必须给表单元素加name属性


# CSS
## 文字控制属性 - 可以继承的属性
* color：文字颜色  color:red;
* font-size：文字大小，属性值是数字+px；  font-size:12px;
    * 在网页里面，能够识别的最小字体为12px
    * 大部分浏览器的默认字体大小是16px
* font-family：文字字体  font-family:”微软雅黑”;
* font-weight：文字是否加粗 
    * normal：正常
    * bold：加粗
    * 数字：100-700
* font-style：文字是否倾斜
    * italic：倾斜
    * normal：正常
* line-height：行高，文字行与行之间的距离
    * 属性值：数字+px
* text-indent：首行缩进，一般用于段落缩进两个文字 
    * text-indent:2em;
    * 1em=1个文字大小
* text-align：文字对齐方式 
    * left  左对齐
    * center  居中
    * right 右对齐
* text-decoration 文本修饰线
    * none 取消任何装饰线条
    * underline  增加下划线
    * line-through  增加删除线
* word-break ：break-all;强制引文单词换行
* letter-spacing：数字+px;   字母与字母/汉字与汉字之间的距离
* word-spacing：数字+px；单词与单词之间的距离，只对英文管用


## 显示模式
#### a.块级显示模式
* 没有设置width的话，width为100%
* 可以成功设置宽高
* 一行只能存在一个块级元素

#### b.行内显示模式
* 内容是多少，元素width就是多少
* 设置宽高不生效
* 一行可以共存多个行内元素

#### c.行内块显示模式
* 可以成功设置宽高
* 一行可以共存多个
* 没有设置width的话，内容是多少，元素width就是多少

#### d.显示模式之间相互转换
* display：inline；将块级元素转化给行内元素；
* display：block；将行内元素转化给块级元素；
* display：inline-block；将元素转化为行内块元素；
* display：none；将元素隐藏（在页面中不显示）

## CSS权重
* 行内式 > 内嵌式 =  外链式 =导入式
* 行内样式，如: style=””，权值为1000。
* id选择器，如：#content，权值为100。
* 类选择选择器，如.content，权值为10。
* 标签选择器，如div p，权值为1  
> 复合选择器最终权重 = 复合选择每个基础选择器权重之和

## 背景 
* background-color
* background-image : url('背景图片的路径');
* background-repeat : repeat | repeat-x | repeat-y | no-repeat;
* background-position : 水平方向  垂直方向
* background-attachment : fixed |  scroll   背景图是否相对于浏览器窗口固定 
> background：背景颜色  背景图  平铺方式   背景图固定 水平方向位置  垂直方向位置；

## 盒子模型
* 外边距 margin --- 盒子与盒子/元素与元素 之间的距离
* 边框线 border
* 内边距 padding  ---- 内容与盒子边缘的距离
* 内容 – 实体化范围 width 和 height

## 使用margin：auto让盒子水平居中的条件 
    * 盒子必要要有宽度
    * 盒子的显示模式必须为块级元素

## 外边距塌陷问题
* 出现环境：嵌套排列的两个盒子，给里面盒子加margin，外面父盒子会随着子盒子移动
* 解决方案如下：
    * a、给父盒子加边框border属性，完整划分出盒子边缘
    * b、给父盒子添加overflow:hidden;属性  （最常用的方式）

## 行内元素的垂直内外边距
* 行内元素的垂直方向margin无效，水平方向margin正常使用
* 行内元素垂直方向的padding有效，但是不能改变行内元素垂直方向位置
* 块级元素和行内块元素的margin和padding可以正常解析

## css初始化
    
    body,h1,h2,h3,h4,h5,h6,p,ul,li,ol,dl,dt,dd,input{ margin:0; padding:0;}
    ul,ol{ list-style:none;}
    body{ color:#666; font-size:12px; font-family:"微软雅黑";}
    a{ color:#333; text-decoration:none;}
    a:hover{ color:#f95d37;}


## 清除浮动
* a.给父元素加overflow：hidden
* b.给父元素加固定高度
* c.给父元素加类名clearfix
    
    	.clearfix:after{
    		height:0;
    		visibility:hidden;
    		content:'';
    		display:block;
    		clear:both;
    		zoom:1;/*兼容ie6*/
    	}

## 定位
* 相对定位：position:relative;
    * 参照物：自己
    * 是脱离标准流的形式 – 属于占位脱离
    * 不能改变元素的显示模式；
* 绝对定位：position:absolute;
    * 参照物：以最近的，已经定位的父级为参照物，如果条件不满足，则浏览器为参照物
    * 绝对定位将盒子的显示模式转化成行内块
    * 绝对定位是完全脱离了标准流的形式，并且不占位
* 固定定位：position:fixed;
    * 参照物：浏览器
    * 固定定位将盒子的显示模式转化成行内块
    * 固定定位是完全脱离了标准流的形式，并且不占位
* 静态定位：position:static;  主要是将元素的定位模式变成正常模式
* 子绝父相 ：子级绝对定位，父级相对定位
  
## 定位盒子居中
* 水平居中：  
    left:50%;margin-left:-自己的宽度一半
* 垂直居中  
    top:50%; margin-top:-自己的高度一半；
    
## z-index属性
z-index属性值
    * 取值为整数（不带任何单位） -- 包含负整数、0、正整数
    * 取值越大，显示级别越靠上

# 初级JS
## 基本数据类型
* 字符串（String）
* 数字(Number)，例如1,2,0.432等数字
* 布尔(Boolean)，只有两个值true和false
* 空（Null）
* 未定义（Undefined）

## 引用数据类型
引用数据类型：
* 对象(Object)
* 数组(Array)
* 函数(Function)。

## 布尔类型（Boolean）
* a.Boolean类型只有两个值 ：true 或者  false
* b.在js中，以下值都代表false：
    * 0
    * null
    * 空字符串
    * false
    * undefined

## 三元运算符 
* 条件表达式 ？表达式1：表达式2
> 条件表达式  为 真  , 执行 表达式1  
条件表达式  为 假  , 执行表达式2

## 逻辑运算符
* 与 : 条件1  &&  条件2     
    * 当条件1和条件2同时为true的时候，此结果为true
* 或: 条件1  ||  条件2     
    * 条件1和条件2，只要有一个为true，此结果为true
* 非
    * !条件   取反  !true--->false  ,    !flase->true

## switch 语句

    switch(n){
	    case  值1:
	    执行代码块 1
	    break;
	    case  值2:
	    执行代码块 2
	    break;
	    default:
	    与 case 1 和 case 2 不同时执行的代码
    }


## 数组
* 创建数组   var arr = new Array();  或者   var arr = [ ];
* 访问数组的内容 : 数组名字[数字]  例如  arr[0]
* 数组的长度 ： 数组名字.length  例如 arr.length

## JSON
* 格式：{ K : V , K : V , K : V , K : V , K : V }
* 输出json的某一项属性值 ： json.k  或者json['key']

    	var json = { name : "lily",  age : 18 , score : 97 , city : "北京" }
    	json.name  或  json['name']   输出为 lily   
    	json.age或   json['age']   输出为  18
    	json.score 或   json['score']   输出为  97
    

## for in循环
#### a.用法

    for(var key in json){
    	key   就是json的每一项键名	
    	json[key]就是每一项的属性值
    }
    例子：
    var json = { 
    	name : "Lily",  
    	age : 18 , 
    	score : 97 
    }
    for(var key in json){
    	console.log(key,json[key]);
    }


## break continue详解
* break 语句用于跳出循环
    * break 只能退出一层循环
    * 使用break之后，for循环里面，break后面的代码都不会执行
* continue 
    * 如果满足条件，结束此轮，继续下一轮
    * continue后面的代码也不会执行

## 函数
#### a.定义函数

    function 自定义函数名字(参数集) {
       //执行的代码
    }
    函数声明后不会立即执行，会在我们需要的时候调用到。
    

#### b.函数调用
自定义函数名字(参数) 

    当我们使用此语法调用的时候，函数里面代码块才会执行。
    function fn(){
    	alert('我是函数');
    }
    fn();


#### c.函数传参
* 在定义函数的时候，书写了几个参数，那么调用的时候，也就需要几个参数
* 而且定义的参数和调用的参数必须一 一对应
* 参数个数可以为0,1,2,3，。。。。。。
* 定义函数的时候，书写的参数叫做形参
* 调用函数的时候，书写的参数叫做实参

#### d.返回值
函数的返回值：返回函数体的结果,调用之后可以用参数来接收结果，并且打印
比如，这个函数的功能是用来计算x+y的，那么在函数最后要把计算结果返回，然后调用的时候，通过定义变量来接收
* 函数返回，通过关键字return来实现

    function add(x,y){
    	return x + y; //通过return将结果返回
    }
    var sum = add(1,2); //通过参数来接收计算结果
    console.log(sum);
    

## 变量作用域
#### a.全局作用域
* 变量在函数外定义，即为全局变量
* 全局作用域: 网页中所有位置都可以访问

        var a = 'a'; //在函数外部定义，属于全局变量
    	var b = 'b';
    	function fn(){
    		console.log(a,b); //全局变量可以在函数内部使用
    	}
    	fn();
    	console.log(a,b);//全局变量可以在函数外部使用
    

#### b.局部作用域
* 变量在函数内声明，变量为局部作用域。
* 局部变量只能在函数内部访问。

        function fn(){
      		var x = 1; //因为x,y是在函数内部定义的，所以属于局部变量
      		var y = 2;
      		//局部变量只能在函数内容使用，所以这里可以正常使用x,y
      		console.log(x,y); 
    	}
    	fn();
    	//这里不可以访问局部变量的x，y
    	console.log(x,y);
    
#### c.变量声明周期
生命周期：从诞生到消费这个期间段叫声明周期
* 局部变量在函数执行完毕后销毁。
* 全局变量在页面关闭后销毁。

##### d.变量提升
在js中	
* 1、变量的声明都将被提升到函数的最顶部
* 2、但是初始化 并不会提升
* 但是 不允许使用未声明的变量

## 字符串方法
#### concat 
* 字符串1.concat(字符串2)  相当于字符串1和字符串2的拼接

	    var str1 = "hello";
	    var str2 = ",world";
	    var str = str1.concat(str2);
	    console.log(str); //c = "hello,world" 


#### charAt 
* 字符串.charAt(n) 返回字符串的第n个字符，从0开始计算

    	//练习：'hello word'中第7个字符是什么
    	var str = 'hello word!';
    	var char = str.charAt(6);
    	console.log(char);
    

#### indexOf
* 字符串1.indexOf(字符串2)  返回字符串2在字符串1中首次出现的位置，找不到则返回-1

    	
    	//练习：判断'hello word'中是否存在'or'字符
    	var str = 'hello word!'
    	var re = str.indexOf('or');
    	console.log(re);


#### split  
* 字符串.split(分离标志)   将一个字符串在分离标志处，分割成数组 


    	//练习：判断'hello word'中是否存在'or'字符
    	 var str = 'hello!word';
    	str.split('!');//["hello", "word"]
    	str.split('');//["h", "e", "l", "l", "o", "!", "w", "o", "r", "d"]
    

#### toUpperCase 
* 字符串.toUpperCase()  将一个英文字符串全部变成大写字母 


    	
    	//练习：将'hello word'字母全部变成大写
    	var str = 'helo word';
    	var re = str.toUpperCase();
    	console.log(re); //HELO WORD
    

#### toLowerCase
* 字符串.toLowerCase()  将一个英文字符串全部变成小写字母 


    	// 练习：将'Hello Word'字母全部变成小写
    	var str = 'Hello Word';
    	var re = str.toLowerCase();
    	console.log(re); //hello word 
    

#### trim  
* 字符串.trim() 去除字符串开头和结尾处的空白字符 

		var str = '   helloword ';
		var re = str.trim();
		console.log(re); 

#### substring：  
* 字符串.substring(start,end) 
* 返回从 start 到 end（不包括）之间的字符
* end如果省略，那么返回的子串会一直到字符串的结尾。

    	var str = 'hello word';
    	str.substring(2,4); // ll
    	str.substring(4,8); // o wo
    	str.substring(4); // o word
    

#### substr  
* 字符串.substr(start,length) 返回字符串中从start位置开始,指定长度的子字符串


    	var str = 'hello word';
    	str.substr(2,2); //ll
    	str.substr(4,1);//o
    	str.substr(4,4);//o wo


## 数组常用方法
#### push
* 数组.push(内容)   向数组的末尾添加新的元素，返回新数组长度

    	练习：向数组里面添加新元素
    	var arr = ['喜羊羊','美羊羊','懒羊羊','村长'];
    	arr.push('小灰灰'); //5
    	arr的结果为['喜羊羊','美羊羊','懒羊羊','村长','小灰灰'];
    

#### pop
* 数组.pop()   删除数组的末尾的元素，返回被删除的元素

    	var arr = ['喜羊羊','美羊羊','懒羊羊','村长'];
    	arr.pop(); // '村长'
    	arr的结果为['喜羊羊','美羊羊','懒羊羊'];
    

#### unshift
* 数组.unshift()   向数组数组的开头添加内容，返回新数组的长度

    	var arr = ['喜羊羊','美羊羊','懒羊羊','村长'];
    	arr.unshift('小灰灰')// 5
    	arr的结果为   ["小灰灰", "喜羊羊", "美羊羊", "懒羊羊", "村长"]


#### shift
* 数组.shift()   删除数组的开头的元素，返回被删除的元素

    	var arr = ['喜羊羊','美羊羊','懒羊羊','村长'];
    	arr.shift(); // '喜羊羊'
    	arr的结果为    ["美羊羊", "懒羊羊", "村长"];
    

#### concat
* 数组1.concat(数组2)   将数组1和数组2拼接成一个数组，返回新数组
不影响数组1和数组2本身

    	var arr1 = ['喜羊羊','美羊羊','懒羊羊','村长'];
    	 var arr2 = ['小灰灰','灰太狼','红太狼'];
    	arr1.concat(arr2)；
		//["喜羊羊", "美羊羊", "懒羊羊", "村长", "小灰灰", "灰太狼", "红太狼"]


#### splice
* 数组.splice(start,length,val1,val2,...)
    * 从start位置开始删除length项，并从该位置起插入val1,val2,...
    * 如果没有后面的替换值，就相当于仅仅删除
    * 返回删除的内容

	    	var arr = ['喜羊羊','美羊羊','懒羊羊','村长','小灰灰','灰太狼','红太狼'];
	    	arr.splice(2,1); // 相当于删除数组第三项
	    	arr.splice(2,4); //相当于删除数组3,4,5项
	    	arr.splice(2,2,'慢羊羊','暖羊羊');//相当于删除3,4项，并用后面替代
    

#### reverse
* 数组.reverse()   将数组反过来，返回反转后的数组

    	var arr = ['喜羊羊','美羊羊','懒羊羊','村长'];
    	arr.reverse(); // ["村长", "懒羊羊", "美羊羊", "喜羊羊"]
    	arr的结果为   ["村长", "懒羊羊", "美羊羊", "喜羊羊"];
    

#### join
* 数组.join(符号)  将数组通过符号拼接到一起，返回拼接的字符串

    	var arr = ['喜羊羊','美羊羊','懒羊羊','村长'];
    	arr.join('-');'喜羊羊-美羊羊-懒羊羊-村长'
    	arr.join(',');//喜羊羊,美羊羊,懒羊羊,村长
    	arr.join(';');//喜羊羊;美羊羊;懒羊羊;村长
    	arr;// ["喜羊羊", "美羊羊", "懒羊羊", "村长"]
    

#### slice
* 数组.slice(start,end)   
    * 截取原数组中start位置到end（不包括）位置之间的项
    * 将截取到的元素组成一个新的数组，并且返回

    		var arr = ['喜羊羊','美羊羊','懒羊羊','村长','小灰灰','灰太狼','红太狼'];
    		 arr.slice(3,6);//["村长", "小灰灰", "灰太狼"]
    		arr 不变


#### sort
* 数组.sort(排序函数)   对数组进行排序
    * 升序：数组.sort(function(a,b){return a-b;})
    * 降序：数组.sort(function(a,b){return b-a;})

    		var arr = [256,4677,356,1,35,53,6];
    		var ascFn = function(a,b){return a-b;} //升序
    		var descFn = function(a,b){return b-a;}  //降序
    		arr.sort(ascFn); //升序排序 arr.sort(descFn);//降序排序
    

## 数学对象
* Math.abs() 获取绝对值  Math.abs(-12) = 12;
* Math.round() 四舍五入
* Math.PI 获取圆周率π 的值
* Math.ceil()  向上取整  只要小数点数字大于0，个位数都加1
* Math.floor() 向下取整  无论后面的数字是多少，全部扔掉
* Math.pow(x,n) 	x的n次冥 
* Math.sqrt(x) 	x的平方根
* Math.random() 取0,1之间的随机小数
    * Math.ceil(Math.random()*n)    1-n之间的随机整数
    * Math.floor(Math.random()*n)    0-n-1 之间的随机整数

## 定时器
#### a.循环定时器

    var timer = setInterval(function(){
    	每隔一段时间就执行一次这里面的代码
    },时间间隔/s)
    
    清除定时器：clearInterval(timer);


## 一次性定时器

    var timer = setTimeout(function(){
    	多长时间之后，执行这里的代码
    },时间间隔/s)
    
    清除定时器：clearTimeout(timer);


## 系统时间
* var myDate=new Date(); 可以通过 new 关键词来定义 Date 对象
    * myDate.getFullYear() 获取当前年份
    * myDate.getMonth() + 1: 获取月份，（0表示1月，11表示12月）
    * myDate.getDate(): 返回日（号）
    * myDate.getDay(): 返回星期，周日为0，周一为1，以此类推（0-6）
    * myDate.getHours(): 返回小时（0-23）
    * myDate.getMinutes(): 返回分钟（0-59）
    * myDate.getSeconds(): 返回秒（0-59）

# 中级JS
## 查找HTML元素
* 通过 id 找到 HTML 元素 getElementById
* 通过标签名找到 HTML 元素 getElementsByTagName
* 通过类名找到 HTML 元素 getElementsByClassName

## HTML标签内容
* 元素.innerHTML  获取元素
* 元素.innerHTML = '改变的内容'；

## HTML标签属性
* 元素.属性名字  可以获取到html的标签属性值  
* 改变HTML标签属性  元素.属性名字 = '新值' 
* 元素.className  可以获取到html的class属性值  
* 元素.className = '新值'   修改元素的class属性值
* 修改css样式  dom'元素.style.css属性名 = css属性值;

## DOM事件
* onclick事件： 在元素被点击时触发
* onmouseenter  鼠标移入元素触发
* onmouseleave   鼠标移出元素触发
* onmousedown   鼠标摁下触发
* onmouseup      鼠标松开触发
* onmousemove   鼠标移动触发
* onload  入口函数

## 闭包
闭包是js里面的一个特殊现象

    var oBtns = document.getElementById('btns').getElementsByTagName('button');
    for(var i=0;i<4;i++){
   	 	console.log(i); //0,1,2,3
    	oBtns[i].onclick=function(){
    		console.log('事件函数里面i的值为：'+i); //4
    	}
    }
    console.log('最终i的值为：'+i); //4

这个案例是闭包最典型，最容易遇到的情况。（面试举例即可）

## this

    dom元素.事件名字 = function(){
    	//这里面的this指的是事件对象
    }


## 排他思想
* 先给所有的标签统一的样式 

	    for(var i=0;i<n;i++){
    		oBtns[i].background = 'blue';
    	}
    	this.background = 'red';


## 自定义索引值
* 1、在for循环里面，点击事件的外面，i是正常的0-4，在这里面将i赋值给每个对象当索引值
* 2、在点击的时候，只要获取点击对象的索引值即可

	    for(var i=0;i<oLis.length;i++){
    		oLis[i].index = i; //自定义索引值
    		oLis[i].onclick = function(){
    			console.log(this.index); //获取索引值
    		}
    	 }


## dom节点操作
* 创建节点  document.createElement('标签名字')  
* 修改新节点内容和属性

    	var newNode = document.createElement('标签名字')  
    	newNode.innerHTML = '新标签的内容';
    	newNode.className = '新标签的class名字'
    	newNode.属性名= '属性值'

* 添加节点  父节点.appendChild(子节点) 向父节点的末尾添加新的子节点
* 删除节点   父元素.removeChild('想要删除的子元素')  从父元素中删除子元素

## dom元素属性
* 元素.clientWidth	    返回元素的可见高度（width + padding值）
* 元素.offsetWidth		返回元素的宽度   （width + padding值 + border值）
* 元素.offsetLeft		 元素的左边框到浏览器左边的距离

## 事件对象
* Event事件对象：代表事件的状态

    	元素.事件名字 = function(event){
    		//event表示事件对象
    	}


## 鼠标位置
* clientX    鼠标位置到浏览器左侧的距离
* clientY     鼠标位置到浏览器顶部的距离
* screenX   鼠标位置到电脑显示屏左侧的距离
* screenY    鼠标位置到电脑显示屏顶部的距离

## 键盘事件对象
* onkeydown    键盘被按下触发
* onkeyup	   键盘被松开触发

## 键值码
* event.keyCode	  可以获取按键的键值码

## 监听事件
* 添加监听：元素.addEventListener('事件名字', 函数体);
* 移除事件监听：元素.removeEventListener('事件名字', 函数体);

## 冒泡捕获
可以通过addEventListener的第三个参数来控制事件是冒泡还是捕获
* false：表示冒泡（默认值）
* true：表示捕获
#### a.冒泡
冒泡：内部元素的事件会先被触发，然后再触发外部元素
#### b.捕获
捕获：外部元素的事件会先被触发，然后才会触发内部元素的事件
#### c.阻止冒泡或捕获
* e.stopPropagation();  注意事件对象e
    * 阻止冒泡：给最里面那个元素的事件加该语句阻止
    * 阻止捕获：给最外面那个元素的事件加该语句阻止

			oBox.addEventListener('click',function(e){
			 	e.stopPropagation();
				console.log('div');
			},false);  


## 正则表达式
#### 语法:  /正则表达式主体/
####  正则验证
* 正则表达式.test('要验证的字符串')
* 如果字符串符合正则表达式的要求，就返回true
* 使用场景：  
我们在做表单的时候，会遇到输入手机号，手机号是11位，我们需要在用户输入完毕提交的时候验证手机号的格式是否正确，给服务器减压。
#### 常用的正则符号
* \d     匹配一个数字
* {n}     匹配n次
* [a-z]  匹配指定范围内的任意字符
* ^     判断是否以。。。开始
* $     判断是否以。。。结束

#### 常用的正则验证表达式
* 验证手机号：/^[1][3,4,5,7,8][0-9]{9}$/
    * 从头开始第一位是1；
    * 第二位是3,4,5,7,8；
    * 后面9个0 - 9 的数字。
* 4-16位用户名：/^[a-zA-Z][a-zA-Z0-9]{3,15}$/
    * 第一位是大小写字母
    * 后面是3-15位字母或者数字
* 8到17位密码：/^[a-zA-Z0-9_.]{8,17}$/  

## 阻止form表单的默认行为
在form标签上加 onsubmit="return false;"

    <form action="#" onsubmit="return false;">
    	<button id="btn">按钮</button>
    </form>
    <script>
	    document.getElementById('btn').onclick = function(){
	    	console.log(1111);
	    }
    </script>


## 阻止双击选中文字
在body标签上直接写onselectstart="return false"

    <body onselectstart="return false"></body>


## this指向
#### 默认this指向：默认情况下，this其实指向的是window  
#### 事件里面定时器this指向
* 在定时器外面，事件里面，this指的是点击对象
* 在定时器里面，this指向的是window

		oBtn.onclick = function(){
			console.log(this); //在定时器外面，事件里面，this指的是点击对象
			setInterval(function(){
				console.log(this); //在定时器里面，this指向的是window
			},1000)
		}


#### 矫正定时器里面的this指向
在定时器外面，点击事件的里面，定义一个变量，赋值为this,然后在定时器里面使用这个变量即可

    oBtn.onclick = function(){
    	var _this = this;
    	setInterval(function(){
    		console.log(_this);
    	},1000)
    }



## AJAX
#### 使用ajax的步骤
* a.创建XMLHttpRequest对象 

    	var xhr; 
    	if (window.XMLHttpRequest) { 
    		xhr=new XMLHttpRequest(); //现代浏览器
    	} else { 
    		xhr=new ActiveXObject("Microsoft.XMLHTTP"); //低级浏览器
    	}


* b.向服务器发送请求 : 两种方式  get 和 post 
    * get：
        * xhr.open('get', '服务器地址')；
        * xhr.send();//get是从服务器取数据，不传参数
    * post：
        * xhr.open('post', '服务器地址')；
        * xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        * xhr.send('参数名1=属性值1&参数名2=属性值2');
* c.等待服务器响应

    	xhr.onreadystatechange = function(){
    	if(xhr.readyState== 4){
    	　　if(xhr.status == 200){ 
    			// 这里书写服务器响应之后的代码
    		}
    	　}
    	}


* 接收服务器的返回值
通过xhr.responseText可以接收到服务器的返回值

    	xhr.onreadystatechange = function(){
    		console.log(xhr.readyState);
    		if(xhr.readyState == 4){
    			console.log(xhr.status);
    	　　		if(xhr.status == 200){ 
    	   			console.log(xhr.responseText);
    			}
    	　　}
    	}

#### ajax完美封装

	ajax({
	    url:'http://192.168.1.67/yima/js06/register.php',
	    data:{
	        username:'小明',
	        password:'123456',
	        phone:'18271627162',
	        code:'1234',
	    },
	    method:'post',
	    success:function(data){
	        var data = JSON.parse(data)
	        console.log(data)
	        if(data.status){
	            alert('注册成功')
	        }
	    }
	})
	function ajax(options){
	    var xhr; 
	    if (window.XMLHttpRequest) { 
	        xhr=new XMLHttpRequest(); //现代浏览器
	    } else { 
	        xhr=new ActiveXObject("Microsoft.XMLHTTP"); //低级浏览器
	    } 
	    if(options.method == 'post'){
	        var str = '';
	        for(var key in options.data){
	            str += key+'='+options.data[key] + '&';
	        }
	        str = str.substring(0,str.length-1);
	        xhr.open('post',options.url);
	        xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
	        xhr.send(str);
	    }else{
	        xhr.open('get',options.url);
	        xhr.send();
	    }
	    xhr.onreadystatechange = function(){
	        console.log(xhr.readyState);
	        if(xhr.readyState== 4){
	            options.success(xhr.responseText);
	        }
	    }
	}    

## BOM
* window.open() - 打开新窗口
* 窗口名字.close() - 关闭当前窗口
* 获取浏览器宽度： window.innerWidth || document.body.clientWidth || document.documentElement.clientWidth;
* 获取浏览器高度：window.innerHeight || document.body.clientHeight||document.documentElement.clientHeight 
* navigator
    * window.navigator 可以获取浏览器的相关信息
    * window.navigator.userAgent 获取浏览器信息及版本
* screen
    * window.screen.availWidth - 可用的屏幕宽度（除去浏览器的状态栏、滚动条等之后的宽度）
    * window.screen.availHeight - 可用的屏幕高度
    * window.screen.width 获取屏幕的实际尺寸
    * window.screen.height
* location
    * window.location 用于获得当前页面的地址 (URL)的相关信息
    * window.location.href     浏览器地址栏中的完整地址串
    * window.location.pathname   URL的路径部分,请求映射的地址
    * window.location.host            获得主机地址
    * window.location.port             获取端口号
*  history
    * window.history ：浏览器访问的历史。
    * window.history.go(n)   里面的参数表示跳转页面的个数
    * window.history.back()  后退  等同于  history.go(-1)
    * window.history.forward()  向前  等同于  history.go(1)

## onresize事件

	window.onresize = function(){
		// 当浏览器被重置大小时执行
	}


## json对象和json字符串转换

	json对象：{
		K1:V1 , K2:V2 , K3:V3 , K4:V4
	}
	json字符串：'{" K1":"V1" , "K2":"V2" , "K3":"V3" , "K4":"V4" }'


* json对象转换成json字符串: JSON.stringify(json);
* json字符串转换成json对象: JSON.parse(jsonStr)；

#### 完全复制一个json和数组
* 1、先将数组或者json转换成字符串
* 2、然后复制
* 3、然后将数组字符串、json字符串转换成数组或者json即可

		var arr = ['a','b','c','d','e','f'];
		var newArr = JSON.parse(JSON.stringify(arr));
		成功将arr复制


## 数据转换
#### 隐式转换
* 1、-   *  /   %  == 	自动将数字字符串变成数值，然后进行计算
* 2、0,null,undefined,null,''	自动转换为false

#### 显式转换
* Number（数据）
    * 1、如果是布尔值，true和false分别被转换为1和0
    * 2、如果是数字值，返回本身。
    * 3、如果是null，返回0.
    * 4、如果是undefined，返回NaN。
    * 5、如果是空字符串，将其转换为0
    * 6、如果是数字字符串转换成数字本身

* parseInt  : 字符串.parseInt() 将字符串转换为整数类型的数值
    * 1、如果第一个字符不是数字符号或者负号，返回NaN
    * 2、如果第一个字符是数字，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止

		    parseInt('   1bg.4gg')   返回  1
    		parseInt('abg456') 返回 NaN
    		parseInt('123.4647')返回 123


* parseFloat : 字符串.parseFloat() 将字符串转换为浮点数类型的数值  
    * 和parseInt用法类似，不过parseFloat()可以识别 .

		    parseFloat('  12.abg')  返回 12
    		parseFloat('  12.23')  返回 12.23
    		parseFloat('   12.23avbe')  返回 12.23
    		parseFloat('vbkjewg')  返回 NaN
    

* toString() : 数据.toString() 
    * 除undefined和null之外，所有类型的值都具有toString()方法，其作用是返回对象的字符串表示

    		var str = true ;  str.toString(); //返回‘true’
    		var str = null;  str.toString();   报错
    		var str ;  str.toString();   报错
    

* String : String(数据)   将任何类型的值转换为字符串
	
	    String(true)  返回  ‘true’
		String(null)  返回  ‘null’
		String(undefined)  返回  ‘undefined’
		String([1,2,3])  返回  ‘1,2,3’
		

* Boolean : Boolean(数据)   将任何类型的值转换为布尔值
	
		Boolean(1)  返回  true
		Boolean(0)  返回  false
		Boolean('')  返回  false
		Boolean(null)  返回  false
		Boolean(undefined)  返回  false
		Boolean('0')  返回  true
		Boolean('null')  返回  true

# jq
## jq常用方法
* jq对象.css()  修改元素的css样式
* jq对象.attr()  修改元素的标签属性
* jq对象.html()  修改标签的内容

## JQ过滤选择器
* ：first  -----  $(‘div:first’) ，选出第一个 
* ：last-----  $(‘div:last’) ，选出最后一个
* ：not()-----  $('div:not(.div01)') ，排除指定的元素
* ：eq()-----  $(‘div:eq(n)’)，过滤出索引值等于n的  
* ：gt()-----  $(‘div:gt(n)’)，过滤出索引值大于n的
* ：lt()-----  $(‘div:lt(n)’)，过滤出索引值小于n的
* ：even -----  $(‘div:even’)，过滤出偶数项的div（从0开始）
* ：odd  -----  $(‘div:odd’)，过滤出奇数项的div（从0开始）

## JQ让元素显示与隐藏
* 显示： 
    * .show(); 
    * .slideDown();
    * fadeIn();
* 隐藏：
    * .hide();
    * .slideUp();
    * .fadeOut();
* 切换： 
    * .toggle();
    * .slideToggle();
    * .fadeToggle();
* 透明度渐变 fadeTo(时间ms，透明度)

## 层级选择器
* '>' 子代选择器，选中儿子  
    * $(‘.box>div’)  //选中.box里面标签为div的儿子
* '+' 选中下面紧挨着的第一个同级标签（选中第一个弟弟）
    * $(‘.box+div’)  //选中下面紧挨着.box的div元素
*  '~' 选中下面的所有同级标签（选中所有的弟弟）
    * $(‘.box~ div’)  //选中.box下面的所有div元素   
* .parent()   查找父节点
* .children()  查找子节点
* .siblings()   查找同级节点
* .closest()    查找祖先元素
* .find()   查找后代元素
* .next()  元素后面同辈元素
* .prev()   元素前面同辈元素

## 类名的添加与删除
* addClass（'类名'）  给元素添加类名
* removeClass（'类名'） 删除元素的类名
* hasClass（'类名'）  判断一个元素是否有某个类名，有的话返回true，没有的话返回false
* toggleClass（'类名'）  元素类名在有和没有之间切换

## hover方法

	jq对象.hover( function(){
		//鼠标移入执行的代码
	} , function(){
		//鼠标移出执行的代码
	})
	如果hover里面仅仅写了一个参数，表示鼠标移入和鼠标移出事件是一样的


## 节点操作
* 创建节点：   $('<节点名字>内容</节点名字>')
* 添加节点：
    * 元素.append(新节点)  ---   追加到标签内部的最后位置
    * 元素.prepend(新节点)   ---  追加到标签内部的最前面
    * 元素.before(新节点)  ---     插入到标签(同级)的前面
    * 元素.after(新节点)   ----   插入到标签(同级)的后面
* 删除节点
    * 节点.remove（）  彻底删除选中的节点（斩早除根）
    * 节点.empty（）    清空选中节点的内部，保留空盒子（斩草留根）

## toast
#### 函数封装
    function toast(options){
	    if(options.type==1){
		     var newNode = $('<div class="my_toast">'+options.message+'</div>');
		     $('body').append(newNode);
		     
		     setTimeout(function(){
		     newNode.remove();
		     },2000)
	    }else if(options.type==2){
		     var newNode = $('<div class="toast_mask"><div class="toast_dialog"><h3>'+options.title+'</h3><p>'+options.message+'</p><div class="toast_btns"><button class="toast_cancel">取消</button><button class="taost_sure">确定</button</div></div></div>');
		     $('body').append(newNode);
		     $('.toast_cancel').click(function(){
		     	$(this).closest('.toast_mask').remove();
		     })
		     $('.taost_sure').click(function(){
		     	$(this).closest('.toast_mask').remove();
		     	options.callback();
		     })
	    }else if(options.type==3){
		     var newNode = $('<div class="toast_mask"><div class="toast_dialog"><h3>'+options.title+'</h3><p>'+options.message+'</p><div class="toast_btns"><button class="taost_sure">确定</button</div></div></div>');
		     $('body').append(newNode);
		     $('.taost_sure').click(function(){
		     	$(this).closest('.toast_mask').remove();
		     	options.callback();
		     })
	    }
    }

#### css样式
    .my_toast{position: absolute;top:50%;left:50%;height:32px;line-height:32px;padding:0 15px;background:rgba(0,0,0,0.8);color:#fff;font-size: 14px;border-radius:5px ;}
    
    .toast_mask{width: 100%;height: 100%;position: fixed;top:0;left:0;background:rgba(0,0,0,0.5);}
    .toast_dialog{background:#fff;width: 400px;height: 180px;position:absolute;top:20%;left:50%;margin-left:-250px;}
    .toast_dialog h3{height:40px;line-height:40px;background:#bbdf88;color:#fff;font-weight: normal;text-align: center;}
    .toast_dialog p{padding:20px 30px;line-height:28px;}
    .toast_btns{padding:0 30px;text-align: center;}
    .toast_btns button{width: 160px;height: 38px;border:none;color:#fff;font-size:16px;background:#bbdf88;cursor: pointer;}
    .toast_btns .toast_cancel{background: #ccc;margin-right: 10px;}

#### js调用
* type:3种类型
	* 1 黑色弹窗   
	* 2 有确定和取消按钮    
	* 3 只有确定按钮
* message  提示信息
* title  标题
* callback   点击确定按钮之后的回调函数
* 
    	toast({
    		type:2,
    		title:'提示',
    		message:'您确定要退出系统吗？',
    		callback:function(){}
    	})

## on、off
* 元素.on(' 事件类型 ',function(){执行方法})
	* 给元素绑定一个或者多个事件
* 元素.off()  解除元素身上的所有事件，包括普通绑定和on绑定的
    * 元素.off(' 事件类型 ')  解除元素绑定的改事件类型
* 给未来元素绑定点击事件：$(document).on('事件类型','选择器',function(){执行方法})


## 自定义动画

	语法 animate({'属性'：'属性值','属性'：'属性值'},动画时间ms，function(){
		//动画完成之后执行的方法，该匿名函数可以省略
	})


* 使用 .stop() 方法来阻止动画排队 ，要写在动画的方法之前

## each遍历函数
* $('').each(function(index,element){     })
  * index 表示当前对象的索引值
  * element 表示当前对象：
* 注意：
  * this也是当前对象，所以在each方法里面，this和element是一个含义
  * each的应用场景是每个被选元素都要单独的设置为不同的样式
  * 如果需求是设置为相同样式，那么只需要选中即可----$（‘’） 

## jq对象和dom对象互相转换
* jq对象：通过jq语法$获取到的对象称为jq对象
* dom对象：通过原生js getElement等获取到的对象称为dom对象

#### jq对象转换成dom对象：

	var jqueryObj = $();//得到Jquery对象
	var domObj = jqueryObj[0];//jqueryObj[0]等同于jqueryObj.get(0)

#### dom对象转换成jq对象

	var  domObj= document.getElementById(id);//得到DOM对象
	var jqueryObj = $(domObj);　　//转换成Jquery对象


## 事件对象
* e.currentTarget   获取绑定事件的元素
* e.target   获取触发该事件的元素
* e.type  获取事件类型
* e.screenX : 参照点：屏幕的左上角。
* e.clientX ：参照点：浏览器的左上角
* e.pageX：参照点：文档(body)  左上角
* position()：{ top：' '，left：' '}  获取它自身相对于参照物的距离，不受margin的影响
* offset() ：{top：' '，left：' '}  获取元素相对于文档（body）的距离

## 滚动事件
* 当滚动选中元素的滚动条时，会触发元素 scroll 事件
    * $(' ').scroll(function( ){  })
* scrollTop()   获取滚动条到顶部的垂直距离
    * $(window).scrollTop();//获取浏览器窗口滚动条到顶部的垂直距离

## resize方法
当调整浏览器窗口的大小时，发生 resize 事件 : $(window).resize(function(){  });

## 元素宽高
* 获取元素的宽度(width属性值)  	元素.width();
* 获取元素的高度(height属性值) 	元素.height(); 
* 修改元素的宽度(width属性值)  	元素.width('值');
* 修改元素的高度(height属性值) 	元素.height('值'); 

 
## 表单事件
* focus() 当元素获得焦点时，触发 focus 事件,让某个元素获取焦点  元素.focus();
* blur() 当元素失去焦点时触发 blur 事件
* change 
    * 当元素的值发生改变时，失去焦点会发生 change 事件。
    * 该事件仅适用于input、 textarea 、 select 元素
    * 当用于 select 元素时，change 事件会在选择某个选项时发生

## ajax
* $.get(url, function(data){ }, [type])
    * url：请求地址
    * function(data){}：data表示服务器返回的数据
    * type：返回内容格式 json, text
* $.post(url, data,function(data){}, [type])
    * url：请求地址
    * data：发送给服务器的数据
    * function(data){}：data表示服务器返回的数据
    * type：返回内容格式 json, text
* $.ajax()

    	$.ajax({
    		url：'请求地址',
    		type：请求的类型，GET 或 POST
    		data：发送给服务器的数据
    		dataType：数据格式，json
    		success：请求成功时运行的函数
    	})


# JS项目实战 #
## 给网页标题加ico图标
* ico文件的制作方式：
	* 1.在百度搜索“ico制作”，例如：http://ico.duduxuexi.com/
	* 2.上传自己的logo，制作成64*64大小的ico文件，并且保存到根目录
* ico的使用：在head中放入如下的标签
 
    	<link rel="shortcut icon " type="images/x-icon" href="./favicon.ico">


## 阻止表单提交
两种方式：

* 1. 在form标签身上加  onsubmit="return false;"
* 2 e.preventDefault();

## 获取input的checked属性值
* $().prop('checked') 获取checked属性,	选中返回true,否则为flase
* $().prop('checked',true|false) 修改复选框选中或者取消 

	    $('#remember').prop('checked');
    	$('#remember').prop('checked',false);

## 定位元素的4个方向
* 当定位元素有固定的width和height时：
	* left和right同时存在，left起作用
	* top和bottom同时存在，top起作用
* 当定位元素没有设置width和height属性时：
	* left和right，top和bottom都起作用

## iframe
iframe  元素会创建另外一个文档，相当于子窗口

* frameborder 子窗口的边框，一般取值为0即可
* height  子窗口的高度
* width 子窗口的高度
* scrolling：yes|auto|no 否在 iframe 中显示滚动条 auto默认值

	`<iframe src="iframe/adminer.html" frameborder="0" id="subFrame"></iframe>`

## 获取子窗口的window对象
* window.frames['子窗口id值'].contentWindow
* window.frames['子窗口name值']
* window.frames[子窗口索引]
* 
#### 复习：
* window.location.reload() 刷新当前页面.
* window.history.back()  后退  
* window.history.forward()   前进

## 修改滚动条的样式

    ::-webkit-scrollbar  {  
    	width: 2px;  /*滚动条宽度*/
    }  
    /*定义滚动条轨道样式*/  
    ::-webkit-scrollbar-track  { 
    	background-color: #ccc;
    }  
    /*定义滑块 样式*/  
    ::-webkit-scrollbar-thumb  { 
    	background-color: #999;  
    }

## jq属性选择器
$('标签名字[属性名=属性值]')  

	例如：
	$('input[type=text]')
	$('input[type=password]')
	$('input[name=username]')

## 使用input-hidden来做隐藏域

因为需要使用input来传递数据，但是又不想要标签显示出来，所以可以使用input，type=hidden隐藏域来完成

    <input type="hidden" name="cId" id="cateId">

# html5 #
## H5新增结构标签
* header ：网页头部标签
* nav     网页导航标签
* section  和 div 类似表示一人完整独立的区域
* aside    一般用来描述侧边栏内容
* article   一般有用来表述一片文字内容的集合
* footer   网站的底部内容

## H5新增表单属性
* placeholder：提示，可以模拟文本框焦点获取和失去时内容切换的效果。
* autofocus : 自动获取焦点，这是一个属性值等于属性名的属性，在书写的时候我们只需要书写属性名就可以，具有该属性的元素会自动获取焦点
* required : 必填项，具有该属性的表单元素为必填项
* autocomplete ： 必须配合name属性值使用
	* on(默认)
	* off(关闭该功能)

## 新增type类型
* email : 具有该类型的 input 框会自动验证里面数据是否符合基本的邮箱格式。( @ )
* url  : 验让是否符合网址格式，需要注意的是它会包括 http://
* number: 具有该类型的 input 里面输入的内容必须是数字
* color: 可以调出当前设备下自带的拾色器
* search: 一般用来做搜索框使用
* range: 滑块
    * value --  当前值 （默认50）        
    * max----最大值（默认100）
* month: 选择显示年月
* date: 选择显示年月日
* time : 选择显示时分秒
* week : 选择显示哪一年的那一周
* datetime-local: 选择显示具体的年月日 时间

## 音频视频标签
* 音频标签 <audio></audio>
* 视频标签 <video></video>

#### 标签属性
* src：音频/视频路径
* autoplay：设置当前音频自动播放,pc端浏览器好多不支持自动播放，但是手机端浏览器支持
* loop：设置音频循环播放
* controls：调出当前设备下自带的播放控件
* preload：视频在页面加载时进行加载，并预备播放。

#### 音频暂停和播放
* .play()   播放音频
* .pause()   暂停当前音频
* .paused   音频是否暂停，停止的话返回true，否则返回false

#### 视频音频播放暂停事件
* 当视频暂停的时候触发onpause事件(dom事件)
* 当视频播放的时候触发onplay事件(dom事件)

## H5储存介绍
* localStorage
* sessionStorage

#### 两者的区别
* localStorage存储的数据是永久性的，除非web应用刻意删除存储的数据，或者用户通过设置浏览器配置来删除，否则数据将一直保留在用户的电脑上，永不过期
* sessionStorage存储的数据，一旦窗口或者标签页被永久关闭了，那么所有通过sessionStorage存储的数据也都被删除了

#### 存、删、取
* localStorage.setItem( ‘键名’,键值 )    储存数据
* localStorage.getItem( ‘键名’ )           获取数据
* localStorage.removeItem( ‘键名’ );    删除数据

## H5新增选择器
#### querySelector
document.querySelector('css选择器')  

    document.querySelector('li') //只能获取到第一个li

#### querySelectorAll
document.querySelectorAll('css选择器')  


    document.querySelectorAll('.orange') 可以获取所有orange

# less #
## 变量
* 以@作为变量的起始标识，变量名由字母、数字、_和-组成
* 定义变量的格式：@变量名: 变量值; @width:100px;
* 引用时采用 "@变量名" 的形式；div{width:@width;}
* 可以对变量进行数学运算

    	@color: red;  //变量
    	@width:1000px;
    	.box{
    		width:@width + 100;//可以对变量进行数学运算
    		background:@color;//引用变量
    	}
    	最终输出：
    	 .box{
    		background:red;
    	 }


## 注释
* // 单行注释，不会作为最终输出：只有程序员可以看到
* '/\*\*/' 
多行注释，以原生CSS的  /\*注释....\*/   形式作为最终输出,
在浏览器里面查看源代码也可以看到

## 选择器嵌套
* Less 提供了使用嵌套代替层叠或与层叠结合使用的能力
* 用 Less 书写的代码更加简洁，并且模仿了 
* HTML 的组织结构。

		li{
		    a{
		        span{
		
		        }
		    }
		}
		解析为：
		li a span{ }

## 嵌套关系中的伪类
当在less的嵌
套关系中 ，需要伪类的时候 可以使用& 表示当前选择器

	a{
	    &:hover{ }
	}
	解析为
	a:hover{ }


## 混合
* 1、使用正常的类选择器书写一些列样式
* 2、在需要这些样式的选择器中，直接调用即可选择器名字();


    	.yangshi{width:200px;}
    	.box{
    		.yangshi();
    	}


## 数组
* 定义数组  
    * @数组名字：元素1，元素2，....元素n；
* 获取数组长度：
    * length(@数组名字)；
* 获取数组第n项
    * extract(@数组名字, n)

## 函数
* 定义一个函数：
* 调用
* 传参
 
    	函数名字(参数集){
    		css样式
    	}
    	函数名字(参数集);

		例子：
    	.setColor(@attr,@value){
    		@{attr}:@value;
    	}
    	
    	li{
    	  .setColor(background,red);
    	 }


## 循环

	知识点：	
	.loop(@变量) when (循环进行的条件) {
	    .loop(让变量增加或者减少);    // 调用自身，让变量增加或者减少
	    width: (10px * @i); 
	}
	
	li{
	    .loop(5)；//调用循环
	}
	
	案例：
	.loop(@i) when (@i > 0) {
	   	 .loop((@i - 1));    // 调用自身，让变量增加或者减少
		// 每次调用时产生的样式代码 50px 40px 30px 20px  10px
	   	 width: (10px * @i); 
	}
	li{
	    .loop(5)
	}

# CSS3 #
## CSS3新增选择器
#### 兄弟选择器
* '>'    儿子
	选中的是子元素（ 只选儿子不选孙子 ）
* '+'    第一个弟弟
	选中兄弟元素，但是只能选中紧挨着某一个元素后面显示的兄弟元素
* '~'    所有的弟弟
	选中某一个元素后面所有的兄弟元素

#### 伪类选择器
* :nth-child( 编号 )  选中第**个编号的元素，从1开始
* :nth-child( 2n )  选中的编号为偶数的元素
* :nth-child( 2n+1 )  选中编号为奇数的元素
* :nth-child( odd || even )---> 分别表示选中编号为奇数和偶数的元素
    * 其中的 n 表示从0 开始的自然数
    * 这里的表达式只能识别 n ，而不识别其它字符。
    * 规律可以随的写，不一定非得是 奇偶数。（2n+2  , 3n+3都可以）
* :first-child  选中父元素下第一个子元素，同样第一个子元素必须是我们想要的类型。
* :last-child   选中最后一个子元素
* :empty  选中内容为空的元素（内容为空格不会被选中）
* :only-child   选中某一个元素，且该元素必须是它父元素下面的唯一的子元素（独生子）
* :only-of-type 选中的元素必须是它父元素下面该类型中唯一的子元素
* :not()  选中某一些元素，然后排除某一类（小括号里面放置的是选择器）
 
## 伪类
* ：before  在之前添加
* ：after     在之后添加
    * 伪类必须配合content属性使用，即使content不需要任何内容，我们也必须留着
    * 生成的是一个行内元素，如果要设置宽高，需要转换显示方式

## css3伪类和iconfont结合
* 将以下代码复制到css中

	    @font-face {
    	  font-family: 'iconfont';
    	  src: url('iconfont.eot');
    	  src: url('iconfont.eot?#iefix') format('embedded-opentype'),
    	  url('iconfont.woff2') format('woff2'),
    	  url('iconfont.woff') format('woff'),
    	  url('iconfont.ttf') format('truetype'),
    	  url('iconfont.svg#iconfont') format('svg');
    	}


* 将iconfont文件夹中的字体文件复制到项目根目录中
* 在需要使用iconfont的标签身上加font-family:iconfont;
* 查看unicode标签页，查看icon对应的编码，然后将编码去掉&#，然后变成‘\e’，放入content中

## 阴影
#### 盒子阴影
box-shadow: x y 模糊 扩展 颜色 内外阴影

* x : 表示水平方向阴影偏移量
* y : 表示垂直方向偏移量，向下为正
* 模糊程度 ：值越大表示阴影越模糊
* 扩展 : 就是阴影向外延伸多大距离开始模糊
* 颜色 : 阴影的颜色
* 内外阴影 :  默认外阴影，如果写了inset表示内阴影

#### 文字阴影
text-shadow: x y 模糊程度 阴影颜色

* x : 表示水平方向阴影偏移量
* y : 表示垂直方向偏移量，向下为正
* 模糊程度 ：值越大表示阴影越模糊。

#### 多个阴影
* 在C3中允许给一个元素同时添加多个阴影，之间用逗号隔开即可。
* 1px 1px 1px green , -1px -1px 1px red;
* 注意：
    * 如果位置阴影位置相同的话，只会显示先写的那个
    * 先写的阴影会在最上面

## 渐变
#### 线性渐变
background：linear-gradient(  )

* linear-gradient(color1,color2)  由上向下，颜色之间用逗号隔开
* linear-gradient(to 方向,color1,color2)  自定义方向，方向可以用	
	* top,bottom,left,right表示
* linear-gradient(度数deg,color1,color2)  自定义方向，顺时针
    * 0表示从下到上
    * 90deg表示从左到右
    * 180deg表示从上到下
    * 270deg表示从右到左

#### 径向渐变
background:radial-gradient(  )

* radial-gradient(color1,color2);由中心向两边扩散
* radial-gradient(at 位置，color1,color2); 
    * at 设置圆心的位置,位置可以用英语单词，也可以使用坐标(相对0,0点计算)
    * radial-gradient(at left top,red,green);
    * radial-gradient(at 50px 50px,red,green);

## 背景尺寸
背景尺寸background-size

* background-size : x y ;  背景图缩放成宽度x，高度y（y可以省略）
* background-size : 百分比 ; 背景图按着盒子的尺寸百分比缩放
* background-size : cover ; 使背景图完全覆盖背景区域
* background-size : contain ; 将背景图缩放至最大使背景图完全适应背景区域

## 内减模式
css3内减模式   box-sizing:border-box;

* 内减模式：盒子的最终宽度 = 设置的width值
    * box-sizing:border-box(內减模式)  
    * box-sizing:content-box（标准模式）


## 过渡属性transition
#### 属性介绍
transition:  属性  动画时间   速度  延时;

* 属性： 可以用all表示所有的属性，也可以单个属性设置
* 动画时间：单位 s
* 速度：默认 ease ，匀速 linear，还有ease-in , ease-out , ease-in-out
* 延时： 单位s，即使是0也不能省略单位


		transiton:width 1s,height 1s;//多个属性用逗号隔开
		transiton：all 1s;//all代表所有属性
		transition:1s;//不写属性，默认是all


#### transition使用
transition是在元素由一个状态变为另一个状态时，能够缓慢变化的属性，一般都是给元素的正常状态里面加transition

	div{ width:100px;transiton:all 1s;}
	div:hover{ width:500px; }


#### js控制样式变化的transition使用
js控制一个元素的类名有或没有，样式的修改，产生的变化，也可以用transition加动画,记得在原样式中加transition

## 转换属性transform
#### 位移
transform:translate(x,y);  

* 以center,center为中心点位移
* x表示x轴位移，y表示y轴位移，y可以省略
* x和y的值：
    * 具体数值，比如100px
    * 百分比 ，x是相对于宽度百分百，y是相对于高度百分比
    * 值可以为正，也可以为负


			transform:translate(100px,100px);  
			transform:translate(100%,-50%);
    

#### 使用translate让元素居中
当不知道容器的宽高的时候，就无法使用定位让容器水平垂直居中，这个时候我们可以使用转换位移来实现水平垂直居中

	div{
	    position: absolute;
	    top:50%;
	    left:50%;
	    transform: translate(-50%,-50%);
	}
	<div>3translate水平垂直居中</div>

#### 让元素水平垂直居中的方法
* 适用于元素宽高特别明确而且不会发生变化的元素
 
	    left:50%;
	    top:50%;
	    margin-left:-100px;
	    margin-top:-100px;	
        
* 适用于宽高不明确或者宽高会发生变化的元素
 
    	left:50%;
    	top:50%;
    	transform: translate(-50%,-50%);

* 适用于有宽高但是宽高可能发生变化的元素

    	left:0;
    	right:0;
    	top:0;
    	bottom:0;
    	margin:auto;


#### 缩放
transform:scale(x,y);

* 以中心点为中心缩放
* x：  x轴缩放倍数， 没有单位
* y： y轴的缩放倍数， 没有单位
* 如果只有一个参数，表示x和y缩放相同倍数


#### 旋转
transform:rotate(旋转角度);

* 以中心点为中心旋转,单位是deg
* 沿着中心点旋转
    * transform:rotateY(度数)  ;  围绕Y轴
    * transform:rotateX(度数)  ;  围绕X轴


			transform:rotate(360deg);
			transform: rotateX(160deg)
			transform: rotateY(160deg)
    

#### 旋转度数问题
transform:rotate 是指旋转到哪个度数，并不是旋转了多少度数

#### 斜切
transform:skew( 角度 )

* 参数表示X 轴方向角度
* 角度值可以为正也可以为负

#### 行内元素的transform
行内元素的transform是无效的，必须转换成块级元素或者行内块才行

#### 混合使用
transform:translate()  rotate()  scale()   skew() 
 
如果一个元素同时拥有多个transform属性，那么可以像background一样混合使用呢，后面的属性不分前后顺序

## 设置旋转基点位置 
transform-origin:以点为中心旋转,配合transform:rotate()：

* transform-origin : 水平方向    垂直方向；

	`transform-origin:left top; 左上点`

* 以线为中心旋转,配合transform:rotateX()或者rotateY()
* transform-origin : 水平方向|垂直方向；


	`transform-origin:top; 上水平线`


## backface-visibility属性
backface-visibility：hidden; 该属性可以设置背对用户的画面不显示

## CSS3 animation
#### 用法
* 调用动画： animation：动画名字 动画时间；
* 定义动画：

	    @keyframes 动画名字{   
    	   from{   }
    	   to{}
    	}


#### 多组动画

	@keyframes 动画名字{   
	   0%{   }
	   ........
	   100%{   }
	}


#### 参数
animation：动画名字  动画时间   动画速度   动画延时  动画次数   逆向；

* 动画次数：正整数  例如  2 表示播放两次 ，没有单位   
  * infinite   无限次播放
* 逆向播放：默认值  normal（不逆向播放）
  * alternate   逆向播放

#### animation单个写法
* 动画名字 ：animation-name:  ;
* 动画时间：animation-duration:1s;
* 动画延时 ：animation-delay:0.6s;

## CSS3弹性布局
#### 属性介绍
Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。
通过display属性，设置flex、inline-flex就可以将盒子变成flex布局

* display：flex；块级弹性盒子，独占一行
* display：inline-flex；行内块弹性盒子，可以和其他行内元素在一行显示

#### 基本概念
* 容器：采用Flex布局的元素，称为Flex容器，简称”容器”。
* 项目：它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”
* 两个轴：水平方向 和 垂直方向
    * 主轴：通过flex-direction属性确定的方向为主轴
    * 交叉轴：那么另一个方向就是交叉轴
设为Flex布局以后，子元素的float、clear属性都将失效

#### 容器属性
这些属性都是flex容器的属性：

* flex-direction   项目的排列方向
* flex-wrap    一行排不下的时候项目的换行方式
* justify-content   主轴上的对齐方式
* align-items   交叉轴上对齐方式
* align-content  多根轴线的对齐方式

#### flex-direction
* flex-direction   决定主轴的方向，即项目的排列方向
* row（默认值）：主轴为水平方向，从左往右排列
* row-reverse：主轴为水平方向，从右往左排列
* column：主轴为垂直方向，从上往下排列
* column-reverse：主轴为垂直方向，从下往上排列

#### flex-wrap
flex-wrap    如果一条轴线排不下，使用flex-wrap来定义换行方式

* nowrap（默认）：不换行
* wrap：换行，第一行在上方
* wrap-reverse：换行，第一行在下方

#### justify-content
justify-content    定义项目在主轴上的对齐方式 (我们假设主轴为水平方向)

* flex-start（默认值）：左对齐
* flex-end：右对齐
* center： 居中
* space-between：两端对齐，项目之间的间隔都相等。
* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

#### align-items
align-items    定义项目在交叉轴上的对齐方式(我们假设交叉轴为垂直方向)

* flex-start：交叉轴的起点对齐。
* flex-end：交叉轴的终点对齐。
* center：交叉轴的中点对齐。
* baseline： 项目的第一行文字的基线对齐。
* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度

#### align-content 
align-content    定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

* flex-start：与交叉轴的起点对齐。
* flex-end：与交叉轴的终点对齐。
* center：与交叉轴的中点对齐。
* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
* stretch（默认值）：轴线占满整个交叉轴

#### align-items和align-content 区别
* align-items  是控制每行里面每个元素是顶对齐还是中线对齐还是基线对齐
* align-content 是控制每行在容器里面的位置如何分布

#### 项目属性 
项目属性是写在flex容器子元素身上的属性：

* flex-grow   占父元素多少比例,该属性用来设置：
    * 当父元素的宽度大于所有子元素的宽度的和时（即父元素会有剩余空间），子元素如何分配父元素的剩余空间。 
    * flex-grow的默认值为0，意思是该元素不分配父元素的剩余空间
    * 如果值大于0，表示分配。值越大，占的比例越大
    
## CSS3浏览器前缀
* 各个浏览器前缀
    * ie         -ms-                （Microsoft简称）
    * 火狐       -moz-             （Mozilla简称）
    * 谷歌和苹果 -webkit-      （Webkit简称)
    * 欧朋       -o-                   （Opera简称)
* 各个浏览器兼容写法
    * 必须把各个浏览器的前缀都加上，而且需要把原始的语句放最后面

## CSS3多列
CSS3 可以将文本内容设计成像杂志一样的多列布局

* column-count 指定需要分割的列数
* column-gap 设置列与列间的距离
* column-rule  设置边框样式、颜色、粗细，和border类似

## 视口标签
使用html:5生成的代码中，有一个meta标签，name是viewport

	<meta name="viewport" content="width=device-width, initial-scale=1.0">   这个标签就是视口标签

*  initial-scale: 页面元素缩放倍数
    * 1    表示1px屏幕显示1px的图片内容
    * 2    表示2px屏幕显示1px的图片内容
    * 0.5 表示0.5px屏幕显示1px的图片内容

## rem和em尺寸
* rem的大小是根据html根标签的字体大小进行计算的。

    	例如html{font-size：30px；}
    	p{font-size:0.5rem;} == p{font-size:0.5*30px} == p{font-size:15px}
    
* em字体大小是根据父元素字体大小设置的。

    	div{font-size:50px;}
    	p{font-size:0.5em;}== p{font-size:0.5*50px} == p{font-size:25px}

## line-height:2和line-height:200%的区别
* line-height：2；  
对父元素设置了line-height: 2后，父元素的子元素会继承line-height: 2这个属性，子元素的行高都是自身font-size的2倍
* line-height:200%;  
对父元素设置了line-height: 200%后，行高=该父元素的font-size*2，是个固定值，子元素会继承该固定值，子元素的字体大小不同，行高都是固定某个值；

## rem适配移动端
#### 通过js动态设置html的font-size

    //设置initial-scale的大小
    var devicePixelRatio = 1/window.devicePixelRatio;
    document.getElementsByName('viewport')[0].content = 'width=device-width, initial-scale='+devicePixelRatio;
    //设置html的字体大小
    var fontSize = document.documentElement.clientWidth/10;
    var oHtml = document.getElementsByTagName('html')[0];
    oHtml.style.fontSize = fontSize + 'px';
    

## 使用flexible.js做适配
直接拿淘宝做好的一个js文件做适配即可：flexible.js
该文件会自动计算initial-scale的值和html的font-size的值，对于我们写移动端有很大帮助

* 用法：	在页面中引入这个js文件即可
* 注意：	必须把页面中原有的meta视口标签删除，否则没有用


